package parser

import (
	"fmt"
	"reflect"
	"testing"
)

func TestParseScores(t *testing.T) {
	text := "Оценка сотрудника по критериям:\n\n1. Профессионализм: 5\nСотрудник демонстрирует высокий уровень профессионализма, о чем свидетельствует его способность давать логические объяснения и находить эффективные решения. Это подтверждается в нескольких отзывах, где коллеги подчеркивают его компетентность и умение решать сложные задачи.\n\n2. Командная работа: 5\nСотрудник отлично работает в команде, о чем говорят отзывы о его конструктивном взаимодействии, командной работе и нацеленности на результат. Это говорит о его способности эффективно сотрудничать с коллегами и вносить свой вклад в достижение общих целей.\n\n3. Коммуникабельность: 5\nСотрудник обладает отличными коммуникативными навыками, о чем свидетельствуют отзывы о его вежливости, мягкости и интеллигентности. Это позволяет ему легко взаимодействовать с коллегами и клиентами, находить общий язык и решать сложные вопросы.\n\n4. Инициативность: 3\nНекоторые отзывы указывают на то, что сотрудник может быть немного консервативен в своих подходах, что может ограничивать его инициативность. Однако другие отзывы указывают на его способность находить эффективные решения, что предполагает, что он обладает некоторой инициативностью.\n\nРезюме: \nСотрудник демонстрирует высокий уровень профессионализма, отличную командную работу и отличные коммуникативные навыки. Однако, ему может быть полезно работать над своей инициативностью, чтобы еще больше"

	expected := map[string]float64{
		"Профессионализм":    5.0,
		"Командная работа":   5.0,
		"Коммуникабельность": 5.0,
		"Инициативность":     3.0,
	}

	result := ParseScoreOnly(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v, получено %v", expected, result)
	}
}

func TestParseScoresWithMissingData(t *testing.T) {
	text := `1. Professionalism: 4.8
Some text without other categories.`

	expected := map[string]float64{
		"Professionalism": 4.8,
	}

	result := ParseScoreOnly(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v, получено %v", expected, result)
	}
}

func TestParseScoresWithInvalidData(t *testing.T) {
	text := `1. Professionalism: five
This text contains invalid score.`

	expected := map[string]float64{}

	result := ParseScoreOnly(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v, получено %v", expected, result)
	}
}

func TestParseCategoryTexts(t *testing.T) {
	text := `Оценка сотрудника по критериям:\n\n1. Профессионализм: 5\nСотрудник демонстрирует высокий уровень профессионализма, о чем свидетельствует его способность эффективно решать сложные задачи и достигать высоких результатов. Это подтверждается в нескольких отзывах, где он показывает 100% результаты по ключевым показателям и успешно внедряет новые решения.\n\n2. Командная работа: 5\nСотрудник отлично работает в команде, о чем говорят отзывы о его способности эффективно взаимодействовать с коллегами и вносить свой вклад в достижение общих целей. Это подтверждается его участием в различных проектах и его способностью оказывать техническую поддержку другим сотрудникам.\n\n3. Коммуникабельность: 4\nСотрудник обладает хорошими коммуникативными навыками, о чем свидетельствуют отзывы о его способности четко объяснять свои решения и взаимодействовать с другими сотрудниками. Однако, отсутствие каких-либо конкретных отзывов о его общении с клиентами или другими заинтересованными сторонами не позволяет给我 оценить его коммуникативные навы на 5.\n\n4. Инициативность: 4\nСотрудник демонстрирует инициативность в своих подходах, о чем свидетельствуют его инициативы по разработке новых решений и внедрению карьерных треков. Однако, некоторые отзывы не указывают на то, что он стремится выходить за рамки своих обязанностей или предлагает новые идеи.\n\nРезюме: \nСотрудник демонстрирует высокий уровень профессионализма, отличную`
	expected := map[string]string{
		"Профессионализм":    "Сотрудник демонстрирует высокий уровень профессионализма, о чем свидетельствует его способность давать логические объяснения и находить эффективные решения. Это подтверждается в нескольких отзывах, где коллеги подчеркивают его компетентность и умение решать сложные задачи.",
		"Командная работа":   "Сотрудник отлично работает в команде, о чем говорят отзывы о его конструктивном взаимодействии, командной работе и нацеленности на результат. Это говорит о его способности эффективно сотрудничать с коллегами и вносить свой вклад в достижение общих целей.",
		"Коммуникабельность": "Сотрудник обладает отличными коммуникативными навыками, о чем свидетельствуют отзывы о его вежливости, мягкости и интеллигентности. Это позволяет ему легко взаимодействовать с коллегами и клиентами, находить общий язык и решать сложные вопросы.",
		"Инициативность":     "Некоторые отзывы указывают на то, что сотрудник может быть немного консервативен в своих подходах, что может ограничивать его инициативность. Однако другие отзывы указывают на его способность находить эффективные решения, что предполагает, что он обладает некоторой инициативностью.",
		"Резюме":             "Сотрудник демонстрирует высокий уровень профессионализма, отличную командную работу и отличные коммуникативные навыки. Однако, ему может быть полезно работать над своей инициативностью, чтобы еще больше",
	}

	result := ParseCriteriaText(text)
	for key, value := range expected {
		fmt.Println(key, value)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v,\nполучено %v", expected, result)
	}
}

func TestParseCategoryTextsWithMultipleEntries(t *testing.T) {
	text := `
1. Professionalism: 4.5
First professionalism text.

2. Teamwork: 4.0
First teamwork text.

1. Professionalism: 5
Second professionalism text.

2. Communication: 4.8
Communication text.

5. Overall Perfomance: 4.8
Text text text
`

	expected := map[string]string{
		"Professionalism":    "Second professionalism text.",
		"Teamwork":           "First teamwork text.",
		"Communication":      "Communication text.",
		"Overall Perfomance": "Text text text",
	}

	result := ParseCriteriaText(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v,\n получено %v", expected, result)
	}
}

func TestParseCategoryTextsWithNoCategories(t *testing.T) {
	text := `This text does not contain any categories that match the pattern.`

	expected := map[string]string{}

	result := ParseCriteriaText(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается пустая карта, получено %v", result)
	}
}

func TestParseCategoryTextsWithIncompleteData(t *testing.T) {
	text := `
1. Professionalism:
No score provided.

2. Teamwork: 4.5
Teamwork text.
`

	expected := map[string]string{
		"Teamwork": "Teamwork text.",
	}

	result := ParseCriteriaText(text)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Ожидается %v, получено %v", expected, result)
	}
}

func TestParseScores1(t *testing.T) {
	type args struct {
		text string
	}
	tests := []struct {
		name string
		args args
		want map[string]float64
	}{
		{
			name: "ok",
			args: args{
				text: "Профессионализм: 5.0 Командная работа: 4.0 Коммуникабельность: 4.0 Инициативность: 4.0 ",
			},
			want: map[string]float64{
				"Профессионализм":    5.0,
				"Командная работа":   4.0,
				"Коммуникабельность": 4.0,
				"Инициативность":     4.0,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := ParseScores(tt.args.text); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ParseScores() = %v, want %v", got, tt.want)
			}
		})
	}
}
